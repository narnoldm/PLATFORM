#include "metadata.hpp"
#include "param.hpp"

#include <set>

using namespace ::std;

int main(int argc, char *argv[])
{
    MPI_Init(&argc, &argv);
    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); //Basic MPI intialization
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    ofstream sink("/dev/null");
    streambuf *strm_buffer = cout.rdbuf();

    paramMap inputFile("QR_pre.inp", rank); 	// input file

    double t2, t1;

    int debug_proc = 0;
    inputFile.getParamInt("stdout_proc", debug_proc);
    if (rank != debug_proc)
    {
        cout.rdbuf(sink.rdbuf());
    }

    // check whether user wants to compute bases or load them
    bool readSolSnaps = false;
	bool readRHSSnaps = false;
    inputFile.getParamBool("readSolSnaps", readSolSnaps); 	// whether to compute solution basis here
	inputFile.getParamBool("readRHSSnaps", readRHSSnaps); 	// whether to compute RHS basis here

	// solution snapshots or basis paths
	string inputSol, inputRHS;
	inputFile.getParamString("solInputString", inputSol); 	// PDP-demarcated input for solution data/basis
    inputFile.getParamString("rhsInputString", inputRHS); 	// PDP-demarcated input for RHS data/basis

	// parse solution and RHS basis strings
	vector<string> tokenSol, tokenRHS;
	cout << "Solution input string is: " << inputSol << endl;
    tokenparse(inputSol, "|", tokenSol);
	cout << "RHS input string is: " << inputRHS << endl;
    tokenparse(inputRHS, "|", tokenRHS);

	// if input strings are same, then resulting bases will be identical
	bool inputMatch = false;
	bool modesDiff = false;

	// if input are identical, bases will just be copied from solution basis to RHS basis
	if (inputSol == inputRHS) {
		cout << "Solution and RHS input strings were identical..." << endl;
		inputMatch = true;
	}

	int numModesSol, numModesRHS;
	string firstFileSnaps, firstFileBasis;

	// setup solution basis input
	meta *datasetSol;
    if (readSolSnaps) {
        datasetSol = new tecIO(tokenSol);
        firstFileSnaps = datasetSol->prefix + to_string(datasetSol->snap0) + datasetSol->suffix;
        dynamic_cast<tecIO *>(datasetSol)->activateReorder(firstFileSnaps.c_str());	
    	inputFile.getParamInt("numModesSol", numModesSol); 			 

    } else {
		datasetSol = new meta(tokenSol);
        firstFileBasis = datasetSol->prefix + to_string(datasetSol->snap0) + datasetSol->suffix;
		numModesSol = datasetSol->nSets;
	}

	// setup RHS/residual basis input, compare parameters against solution basis input
	meta *datasetRHS;
	if (readRHSSnaps) {
		datasetRHS = new tecIO(tokenRHS);
		firstFileSnaps = datasetRHS->prefix + to_string(datasetRHS->snap0) + datasetRHS->suffix;
		dynamic_cast<tecIO *>(datasetRHS)->activateReorder(firstFileSnaps.c_str());
		inputFile.getParamInt("numModesRHS", numModesRHS);

		// if dataset is same and mode counts are not same, note this
		// I'm pretty sure the readSolSnaps check is redundant, if inputMatch is already true
		if ( (readSolSnaps) && (inputMatch) && (numModesSol != numModesRHS) ) {
			modesDiff = true;
			cout << "Solution and RHS bases have same datasets, but different mode counts..." << endl;
		}

	// setup basis if reading basis
	} else {
		datasetRHS = new meta(tokenRHS);
		firstFileBasis = datasetRHS->prefix + to_string(datasetRHS->snap0) + datasetRHS->suffix;
		numModesRHS = datasetRHS->nSets;

		if (!readSolSnaps) {
			int metaCheck = compareMeta(datasetSol, datasetRHS);
			if (metaCheck == 2) {
				modesDiff = true;
				cout << "Solution and RHS bases have same datasets, but different mode counts..." << endl;
			} 
		}
	}
	int numModesMax = max(numModesSol, numModesRHS); // determines which basis has more modes, only relevant if bases come from same dataset

	// percentage of total cells to be sampled 
    double pSampling;
    inputFile.getParamDouble("pSampling", pSampling);

	// some I/O path strings
    string deimFolder, deimPrefix, dfd_itype_file;
    inputFile.getParamString("deimModesFolder", deimFolder); 	// location where DEIM interpolant modes will be written
	if (!rank)
		system(("mkdir " + deimFolder).c_str()); 				// make folder here so we can write everything into its proper folder
    inputFile.getParamString("deimModesPrefix", deimPrefix); 	// prefix of DEIM interpolant mode files
    inputFile.getParamString("dfd_itype_file", dfd_itype_file); // path to dfd_itype.bin generated by pgrid.x

	PGrid *evenG;
    evenG = new PGrid(rank, size, 0);
	pMat *U, *A, *VT; 	// temporary basis matrices
	pMat *USol;
	pMat *URHS, *URHS_T;

	// ##### SETTING UP SOLUTION TRIAL BASIS ##### // 
	cout << "Loading solution basis..." << endl;

	int nCells = 0, nVars = 0, nDOF = 0;

	// compute SVD of FOM snapshots, if computing POD basis here
    if (readSolSnaps) {

        A = new pMat(datasetSol->nPoints, datasetSol->nSets, evenG, 0, 0, 0.0, false);
        t1 = MPI_Wtime();
        datasetSol->batchRead(A);
        t2 = MPI_Wtime();
        cout << "Load took " << t2 - t1 << " seconds" << endl;

        t1 = MPI_Wtime();

		// TODO: this would need to include options to set centering and normalization profiles
        tecIO *datasetTec = dynamic_cast<tecIO *>(datasetSol);
        datasetTec->calcAvg(A);
        datasetTec->subAvg(A);
        datasetTec->calcNorm(A);
        datasetTec->normalize(A);

        t2 = MPI_Wtime();
        cout << "Preprocessing took " << t2 - t1 << " seconds" << endl;
        int MSol = datasetSol->nPoints; 
		int NSol = datasetSol->nSets;

        vector<double> SSol;

        U = new pMat(MSol, min(MSol, NSol), evenG, false);
        VT = new pMat(min(MSol, NSol), NSol, evenG, false);
        SSol.resize(min(MSol, NSol));

        A->svd_run(MSol, NSol, 0, 0, U, VT, SSol);
        destroyPMat(A, false);
        destroyPMat(VT, false);

		nCells = dynamic_cast<tecIO *>(datasetSol)->nCells;
		nVars  = dynamic_cast<tecIO *>(datasetSol)->numVars;

		// extract numModesSol modes from U
		USol = new pMat(U->M, numModesSol, evenG, false);
		USol->changeContext(U, U->M, numModesSol, 0, 0, 0, 0, false);
		
		// if basis datasets match, also extract RHS basis here
		if (inputMatch) {
			URHS = new pMat(U->M, numModesRHS, evenG, false);
			// if mode counts are different, extract modes from U
			if (modesDiff) {
				URHS->changeContext(U, U->M, numModesRHS, 0, 0, 0, 0, false);

			// if bases are identical
			} else {
				URHS = USol; // just use same address, don't need to allocate more memory
			}

		}

		destroyPMat(U, false); // don't need this anymore

    } else {
		// have to provide number of cells and variables, since reading from binary here (not SZPLT)
		inputFile.getParamInt("nCells", nCells); 
        inputFile.getParamInt("nVars", nVars);

		// read modes from disk
		USol = new pMat(datasetSol->nPoints, datasetSol->nSets, evenG, false);
		if (inputMatch || (modesDiff && (numModesSol < numModesMax))) {
			// if bases are identical, or if same basis set and RHS basis has more modes, just load it now
			URHS = new pMat(datasetRHS->nPoints, datasetRHS->nSets, evenG, false);
			datasetRHS->batchRead(URHS);
			USol->changeContext(URHS, URHS->M, numModesSol, 0, 0, 0, 0, false);
		} else {
			// if bases totally different, of solution basis set is same but has more modes than RHS basis, load solution basis now
			datasetSol->batchRead(USol);
		}

	}
    nDOF = nCells * nVars;

	// ##### FINISH SOLUTION TRIAL BASIS ##### //

	// ##### SETTING UP RHS BASIS ##### //
	cout << "Loading RHS/residual basis..." << endl;

	// compute SVD of FOM snapshots, if computing POD basis here
	if (readRHSSnaps)
	{
		// if inputMatch, this has already been computed
		if (!inputMatch) {
			A = new pMat(datasetRHS->nPoints, datasetRHS->nSets, evenG, 0, 0, 0.0, false);
			t1 = MPI_Wtime();
			datasetRHS->batchRead(A);
			t2 = MPI_Wtime();
			cout << "Load took " << t2 - t1 << " seconds" << endl;

			t1 = MPI_Wtime();

			// TODO: this would need to include options to set centering and normalization profiles
			tecIO *datasetTec = dynamic_cast<tecIO *>(datasetRHS);
			datasetTec->calcAvg(A);
			datasetTec->subAvg(A);
			datasetTec->calcNorm(A);
			datasetTec->normalize(A);

			t2 = MPI_Wtime();
			cout << "Preprocessing took " << t2 - t1 << " seconds" << endl;
			int MRHS = datasetRHS->nPoints; 
			int NRHS = datasetRHS->nSets;

			vector<double> SRHS;

			U = new pMat(MRHS, min(MRHS, NRHS), evenG, false);
			VT = new pMat(min(MRHS, NRHS), NRHS, evenG, false);
			SRHS.resize(min(MRHS, NRHS));

			A->svd_run(MRHS, NRHS, 0, 0, U, VT, SRHS);
			destroyPMat(A, false);
			destroyPMat(VT, false);

			assert(nCells == dynamic_cast<tecIO *>(datasetRHS)->nCells);
			assert(nVars  == dynamic_cast<tecIO *>(datasetRHS)->numVars);

			// extract numModesRHS modes from U
			URHS = new pMat(U->M, numModesRHS, evenG, false);
			URHS->changeContext(U, U->M, numModesRHS, 0, 0, 0, 0, false);
			destroyPMat(U, false); 
		}
		
		// URHS_T is just transpose of URHS
		URHS_T = new pMat(numModesRHS, URHS->M, evenG, false);
		URHS_T->transpose(URHS, URHS_T->M, URHS_T->N, 0, 0);

	} else {

		// if inputMatch, basis has already been copied
		if (!inputMatch) {
			URHS = new pMat(datasetRHS->nPoints, datasetRHS->nSets, evenG, false);

			// if same basis set, but RHS basis has fewer modes than solution basis, extract first numModesRHS modes from USol
			if (modesDiff && (numModesRHS < numModesMax)) {
				URHS->changeContext(USol, USol->M, numModesRHS, 0, 0, 0, 0, false);

			// otherwise just load from disk
			} else {
				// read RHS modes from disk
				datasetRHS->batchRead(URHS);
			}
		}

		// URHS_T is just transpose of URHS
		URHS_T = new pMat(numModesRHS, URHS->M, evenG, false); 						
		URHS_T->transpose(URHS);
		assert(URHS_T->N == nDOF);

	}

	// ##### FINISH RHS BASIS ##### //

	// ##### START SAMPLING ##### //

	// type of sampling
	// 1: QR + random oversampling
	// 2: QR + eigenvector-based oversampling
	// 3: DEIM greedy oversampling
	int sampType;
	inputFile.getParamInt("sampType", sampType);

	// compute QR factorization of U^T
	// This writes the pivot indices to disk, since it's easier to do this than collect to rank 0 process
	int PointsNeeded = max(numModesRHS, int(nCells * pSampling)); // total number of cells that need to be sampled
	vector<int> P;

	if (sampType != 3) {
		cout << "Computing QR decomposition..." << endl;
    	URHS_T->qr_run(URHS_T->M, URHS_T->N, 0, 0, P, deimFolder, false);  // contents of URHS_T are DESTROYED during QR decomposition
	}
	destroyPMat(URHS_T, false); 

    vector<int> gP;		// gP will contain zero-indexed cell IDs of sampled cells
    vector<int> itype;
    set<int> samplingPoints;

	// get QR and boundary points
    t1 = MPI_Wtime();

	// all sampling here is done by rank 0 process
    if (rank == 0)
    {
		if (sampType != 3) {
			readMat(deimFolder+"/P.bin", gP); 	// automatically resizes gP to nDOF (the size of P.bin)
			gP.resize(numModesRHS); 	// resize it back down to numModesRHS. I feel like readMat just read the first numModesRHS integers? Seems inefficient.

			// sampled QR cells
			cout << "Extracting QR points..." << endl;
			for (int i = 0; i < gP.size(); i++)
			{
				gP[i]--; //switch to 0 indexing

				//switch to zero-indexed cell IDs
				cout << i << " " << gP[i] << " " << endl;
				gP[i] = gP[i] % nCells;
				auto check = samplingPoints.emplace(gP[i]);
				if (!check.second)
				{
					cout << "Repeated element" << endl;
				}
			}
			cout << "Goal is " << PointsNeeded << " points" << endl;
			cout << "Points after qr: " << samplingPoints.size() << " of " << PointsNeeded << endl;
		}

		// get desired boundary labels
		int numSampledBounds = 0;
		string labelInputString;
		inputFile.getParamInt("numSampledBounds", numSampledBounds);
		vector<int> bcLabels(numSampledBounds);
		for (int i = 0; i < numSampledBounds; ++i) {
			labelInputString = "boundLabel" + to_string(i+1);
			inputFile.getParamInt(labelInputString, bcLabels[i]);
			cout << "Extracting boundary w/ label: " << bcLabels[i] << endl;
		}

		// add boundary cells, if any
		if (numSampledBounds > 0) {
			cout << "Extracting boundary points..." << endl;
			readMat(dfd_itype_file, itype);
			for (vector<int>::iterator it = itype.begin(); it != itype.end(); ++it)
			{
				// check if we want to sample this cell's itype (i.e. itype is in bcLabels)
				if (find(bcLabels.begin(), bcLabels.end(), *it) != bcLabels.end()) {
					auto check = samplingPoints.emplace(it - itype.begin()); //  add index of interator (i.e. cell_id, zero-indexed) 
					if (!check.second)
					{
						cout << "Repeated element " << it - itype.begin() << "\r";
					}
				}
			}
			cout << endl << "Points after boundaries: " << samplingPoints.size() << " of " << PointsNeeded << endl;
			assert(PointsNeeded >= samplingPoints.size());
			cout << "Need " << PointsNeeded - samplingPoints.size() << " more points" << endl;
		} else {
			cout << "No boundaries sampled..." << endl;
		}
	}
	MPI_Barrier(MPI_COMM_WORLD);

	// oversampling
	bool allPoints = false;

	// random oversampling
	if (sampType == 0) {
		cout << "No oversampling..." << endl;
	} else if (sampType == 1) {
		// do everything on rank 0
		if (rank == 0) {

			cout << "Randomly oversampling..." << endl;

			srand(1);				// seed random number generator
			vector<int> rPoints;
			rPoints.resize(nCells, 0);
			for (int i = 0; i < rPoints.size(); i++)
				rPoints[i] = i;

			// selecting points from a randomly shuffled list of integers from 0 to ncells-1				
			random_shuffle(rPoints.begin(), rPoints.end());
			for (vector<int>::iterator it = rPoints.begin(); it != rPoints.end(); ++it)
			{
				auto check = samplingPoints.emplace(*it);
				if (!check.second)
				{
					cout << "repeated element " << *it << "\r";
				}
				if (samplingPoints.size() == PointsNeeded) {
					cout << endl << "All points found..." << endl;
					allPoints = true;
					break;
				}
			}

			// this should theoretically never happen
        	if (!allPoints) {
				cout << endl << "Somehow, could not find enough sampled, this should never happen." << endl;
				return(-1);
			}

		}

	// eigenvector-based oversampling
	} else if (sampType == 2) {

		// declare some variables for this routine
		pMat *U_E, *VT_E;
		vector<double> S_E;
		int M, N, minDim;
		int numQRPoints, numCurrentPoints, numCurrentDOFs;
		int cellID;

		pMat *rVec = new pMat(1, nDOF, evenG, false); 
		pMat *rVec_p0 = new pMat(1, nDOF, evenG, 0, 2, 0.0, false);
		vector<int> sortIdxs(nDOF);
		vector<double> rVec_vector(nDOF);

		// sort and broadcast gP to all processes
		if (rank == 0)
			numQRPoints = samplingPoints.size();

		MPI_Bcast(&numQRPoints, 1, MPI_INT, 0, MPI_COMM_WORLD);
		if (rank != 0)
			gP.resize(numQRPoints, 0);
		MPI_Bcast(gP.data(), gP.size(), MPI_INT, 0, MPI_COMM_WORLD);
		numCurrentPoints = numQRPoints;

		// grab first QR point rows, BUT ordered by cell, then by var
		pMat *URHS_samp_E = new pMat(PointsNeeded*nVars, datasetRHS->nSets, evenG, false);
		pMat *URHS_samp_E_copy = new pMat(PointsNeeded*nVars, datasetRHS->nSets, evenG, false);
		for (int j = 0; j < numCurrentPoints; ++j) {
			for (int k = 0; k < nVars; ++k)
				URHS_samp_E_copy->changeContext(URHS, 1, numModesRHS, gP[j] + k * nCells, 0, j * nVars + k, 0, false);
		}

		// loop over number of requires samples left
		for (int i = 0; i < (PointsNeeded - numQRPoints); ++i) {

			cout << (double)i / (PointsNeeded - numQRPoints) * 100 << " percent GappyPOD+E points sampled \r";

			numCurrentDOFs = numCurrentPoints * nVars;

			// copy first numCurrentDOFs rows from URHS_samp_E_copy to URHS_samp_E
			// we do this because URHS_samp_E will be destroyed during the SVD
			URHS_samp_E->changeContext(URHS_samp_E_copy, numCurrentDOFs, numModesRHS, 0, 0, 0, 0, false);

			// compute SVD of sampled URHS, hold on to singular values and RIGHT singular vectors
			M = numCurrentDOFs; 
			N = numModesRHS;
			minDim = min(M,N);

        	U_E = new pMat(M, minDim, evenG, false); 	// this will always change, must be reallocated/deleted
        	VT_E = new pMat(minDim, N, evenG, false); // this *might* not need to be reallocated/deleted every iterations, could always be [numModesRHS x numModesRHS]
			S_E.resize(minDim, 0.0);

			URHS_samp_E->svd_run(M, N, 0, 0, U_E, VT_E, S_E, false); // contents of URHS_samp_E are destroyed during SVD
			destroyPMat(U_E, false);

			// compute vector-matrix product of last right singular vector transposed and URHS transposed
			rVec->matrix_Product('N', 'T', 1, nDOF, minDim, VT_E, minDim-1, 0, URHS, 0, 0, 1.0, 0.0, 0, 0);
			destroyPMat(VT_E, false);

			// reduce rVec to rank 0 
			rVec_p0->changeContext(rVec, false);

			if (rank == 0) {

				// square all elements of rVec
				for (int j = 0; j < rVec_p0->dataD.size(); ++j)
					rVec_p0->dataD[j] = pow(rVec_p0->dataD[j], 2.0);

				// fill vector, since the argsort doesn't seem to work with pMat.dataD
				for (int j = 0; j < nDOF; ++j)
					rVec_vector[j] = rVec_p0->dataD[j];

				// argsort rVec, in DESCENDING order
				iota(sortIdxs.begin(), sortIdxs.end(), 0);
				stable_sort(sortIdxs.begin(), sortIdxs.end(), [&rVec_vector](int i1, int i2) { return rVec_vector[i1] > rVec_vector[i2]; });
				// This would be preferable, and not have to use rVec_vector, but I cannot get it to compile, I don't know what's going wrong
				// stable_sort(sortIdxs.begin(), sortIdxs.end(), [&(rVec_p0->dataD)](int i1, int i2) { return rVec_p0->dataD[i1] < rVec_p0->dataD[i2]; });

				// iterate through rVec, emplacing corresponding zero-indexed cell ID into samplingPoints until a new point is found
				for (int j = 0; j < nDOF; ++j) {
					cellID = sortIdxs[j] % nCells;
					auto check = samplingPoints.emplace(cellID);
					if (check.second)
						break;
				}

			}

			cout << endl << "Cell ID: " << cellID << endl;

			// broadcast new cell ID to all processes, insert into gP vector
			MPI_Bcast(&cellID, 1, MPI_INT, 0, MPI_COMM_WORLD);			
			gP.push_back(cellID);
			numCurrentPoints++;

			// append newly sampled rows of URHS to URHS_samp_E_copy
			for (int k = 0; k < nVars; ++k)
				URHS_samp_E_copy->changeContext(URHS, 1, numModesRHS, k * nCells + gP.back(), 0, (numCurrentPoints-1) * nVars + k, 0, false);

		}

		// cleanup
		cout << endl;
		destroyPMat(URHS_samp_E, false);
		destroyPMat(URHS_samp_E_copy, false);
		destroyPMat(rVec, false);
		destroyPMat(rVec_p0, false);

	// DEIM greedy sampling
	} else if (sampType == 3) {
	
		// // declare some variables for this routine
		// pMat *rVec = new pMat(nDOF, 1, evenG, false); 
		// pMat *rVec_p0 = new pMat(nDOF, 1, evenG, 0, 2, 0.0, false);
		// vector<int> sortIdxs(nDOF);
		// vector<double> rVec_vector(nDOF);
		// int oversampThresh, modeIdx; 

		// // extract first column of URHS to rVec
		// rVec->changeContext(URHS, nDOF,  1, 0, 0, 0, 0, false);

		// // loop over number of desired sampling points (index i)
		// for (int i = 0; i < PointsNeeded; ++i) {
			
		// 	if (rank == 0) {
		// 		// get argmax of absolute value of rVec
		// 		iota(sortIdxs.begin(), sortIdxs.end(), 0);
		// 		stable_sort(sortIdxs.begin(), sortIdxs.end(), [&rVec_vector](int i1, int i2) { return rVec_vector[i1] > rVec_vector[i2]; });

		// 		// while loop until new cell is added
		// 		for (int j = 0; j < nDOF; ++j) {
		// 			cellID = sortIdxs[j] % nCells;
		// 			auto check = samplingPoints.emplace(cellID);
		// 			if (check.second)
		// 				break;
		// 		}

		// 		oversampThresh = min(numModesRHS, i); // forces ceiling of numModesRHS


		// 	}


		// 	// d = min(numModesRHS-1, i)  // index to check whether this is oversampling or normal sampling

		// 	// k = mod(i, numModesRHS) // index to get oversampling index

		// 	// c = URHS

		// }

	} else {
		cout << "Invalid choice of sampling type: " << sampType << endl;
	} 
	MPI_Barrier(MPI_COMM_WORLD);

	
	if (rank == 0) {
		gP.resize(samplingPoints.size(), 0);
        vector<double> gPD; // gP, but doubles
		gPD.resize(nCells, 0.0);
        copy(samplingPoints.begin(), samplingPoints.end(), gP.begin());

		cout << "Writing sampling points to disk..." << endl;
        for_each(gP.begin(), gP.end(), [](int &tt) { tt += 1; }); 	// put in one-indexed format for writing to disk
        printASCIIVecP0(deimFolder+"/samplingPoints.txt", gP, gP.size()); 		// writes sampling points to disk
        writeMat(deimFolder+"/Pall.bin", gP.size(), 1, gP); 			// also writing as bin file
        for_each(gP.begin(), gP.end(), [](int &tt) { tt -= 1; }); 	// changing back to zero-indexed cell IDs

		// mark every sampled cell in gPD with 1.0
        for (int i = 0; i < samplingPoints.size(); i++)
            gPD[gP[i]] = 1.0;

        vector<string> Pname;
        string tempname = "sampling";
        Pname.push_back(tempname);

		// could probably generalize this without the conditionals
        if (readSolSnaps) {
			dynamic_cast<tecIO *>(datasetSol)->writeSingleFile("sampling.szplt", Pname, gPD.data(), firstFileSnaps);
		} else if (readRHSSnaps) {
			dynamic_cast<tecIO *>(datasetRHS)->writeSingleFile("sampling.szplt", Pname, gPD.data(), firstFileSnaps);
		}

    }

    t2 = MPI_Wtime();
    cout << "Finding all samples took " << t2 - t1 << " seconds" << endl;

    if (rank != 0)
    {
        gP.resize(PointsNeeded, 0);
    }
    cout << "Broadcasting points..." << endl;
    MPI_Bcast(gP.data(), gP.size(), MPI_INT, 0, MPI_COMM_WORLD);

    cout << "Calculating DEIM interpolant..." << endl;
	
	// URHS_samp is P^T * URHS
    pMat *URHS_samp;
	URHS_samp = new pMat(gP.size() * nVars, numModesRHS, evenG, false);

	// extract rows of URHS
	// would it not be easier to just construct the full selection matrix P? Then multiply P^T * U?

	// permute rows with pdlapiv, then copy first gp.size()*nVars rows

	// multiply URHS by actual selection matrix

	// copying individual rows of URHS
    t1 = MPI_Wtime();
	cout << "gP size: " << gP.size() << endl;
	for (int i = 0; i < gP.size(); ++i) {
		cout << gP[i] << endl;
	}
    for (int i = 0; i < gP.size(); i++)
    {
        cout << (double)i / gP.size() * 100 << " percent points extracted \r";
		for (int j = 0; j < nVars; j++)
			URHS_samp->changeContext(URHS, 1, numModesRHS, gP[i] + j * nCells, 0, i + j * gP.size(), 0, false);
    }
    t2 = MPI_Wtime();
    cout << endl << "Extraction of RHS basis rows took " << t2 - t1 << " seconds" << endl;


    t1 = MPI_Wtime();

	// compute [P^T * URHS]^+ component of DEIM interpolant
	cout << "Computing pseudo-inverse..." << endl;
    pMat *pinvURHS_samp = new pMat(URHS_samp->N, URHS_samp->M, evenG, false);
    pinvURHS_samp->pinv(URHS_samp);
	destroyPMat(URHS_samp, false);

	// compute USol^T * URHS
	cout << "Computing V^T * U ..." << endl;
    pMat *USol_URHS = new pMat(numModesSol, numModesRHS, evenG, false);
    USol_URHS->matrix_Product('T', 'N', numModesSol, numModesRHS, USol->M, USol, 0, 0, URHS, 0, 0, 1.0, 0.0, 0, 0); 

	// compute full DEIM interpolant, USol^T * URHS * [P^T * URHS]^+
	cout << "Computing complete DEIM interpolant..." << endl;
    pMat *deimInterp = new pMat(USol_URHS->M, pinvURHS_samp->N, evenG, false);
    deimInterp->matrix_Product('N', 'N', deimInterp->M, deimInterp->N, pinvURHS_samp->M, USol_URHS, 0, 0, pinvURHS_samp, 0, 0, 1.0, 0.0, 0, 0);
    t2 = MPI_Wtime();
    cout << "DEIM interpolant calculation took " << t2 - t1 << " seconds" << endl;

    // clean up
    destroyPMat(USol_URHS, false);
    destroyPMat(pinvURHS_samp, false);

    pMat *deimInterp_T = new pMat(deimInterp->N, deimInterp->M, deimInterp->pG, false);
    deimInterp_T->transpose(deimInterp);
    destroyPMat(deimInterp, false);

	// write DEIM interpolant to disk
    // insert zeros where it is not sampled, for GEMS input
	cout << "Emplacing zeros into DEIM interpolant..." << endl;
    t1 = MPI_Wtime();
	pMat *deimInterpOut = new pMat(datasetRHS->nPoints, numModesSol, evenG, false);
    for (int i = 0; i < gP.size(); i++)
    {
        cout << (double)i / gP.size() * 100 << " percent points emplaced \r";
		for (int j = 0; j < nVars; j++)
			deimInterpOut->changeContext(deimInterp_T, 1, numModesSol, i + j * gP.size(), 0, gP[i] + j * nCells, 0, false);
    }
    t2 = MPI_Wtime();
    cout << endl << "DEIM emplacement took " << t2 - t1 << " seconds" << endl;

	// what is the purpose of this? We can't use this stuff with GEMS, and it will get activated no matter what if computing the SVD
    if (readSolSnaps || readRHSSnaps) {
        tecIO *datasetOut = new tecIO();
        datasetOut->snap0 = 1;
        datasetOut->snapF = deimInterpOut->N;
        datasetOut->snapSkip = 1;
        datasetOut->nSets = deimInterpOut->N;
        //datasetOut->prefix = "deimInterp";
        //datasetOut->suffix = ".szplt";
        datasetOut->isInit = true;

		if (readSolSnaps) {
			datasetOut->meshFile = datasetSol->prefix + to_string(datasetSol->snap0) + datasetSol->suffix;
			datasetOut->varName = dynamic_cast<tecIO *>(datasetSol)->varName;
        	datasetOut->varIndex = dynamic_cast<tecIO *>(datasetSol)->varIndex;
		} else {
			datasetOut->meshFile = datasetRHS->prefix + to_string(datasetRHS->snap0) + datasetRHS->suffix;
			datasetOut->varName = dynamic_cast<tecIO *>(datasetRHS)->varName;
        	datasetOut->varIndex = dynamic_cast<tecIO *>(datasetRHS)->varIndex;
		}
        
        datasetOut->fixedMesh = true;
        datasetOut->getDimNodes();
        datasetOut->numVars = datasetOut->varName.size();
        datasetOut->nPoints = datasetOut->nCells * datasetOut->numVars;

        datasetOut->activateReorder(firstFileSnaps.c_str());
        datasetOut->activateGEMSbin(firstFileSnaps.c_str());
        t1 = MPI_Wtime();
        datasetOut->batchWrite(deimInterpOut, deimFolder, deimPrefix);
        t2 = MPI_Wtime();
        cout << "Output took " << t2 - t1 << " seconds" << endl;
    
	} else {
        meta *datasetOut = new meta();
        datasetOut->snap0 = 1;
        datasetOut->snapF = deimInterpOut->N;
        datasetOut->snapSkip = 1;
        datasetOut->nSets = deimInterpOut->N;
        datasetOut->prefix = "deimInterp";
        datasetOut->suffix = ".bin";
        datasetOut->isInit = true;

        datasetOut->nPoints = nCells * nVars;
        assert(datasetOut->nPoints == nCells * nVars);
        t1 = MPI_Wtime();
        datasetOut->batchWrite(deimInterpOut, deimFolder, deimPrefix);
        t2 = MPI_Wtime();
        cout << "Output took " << t2 - t1 << " seconds" << endl;
    }

    cout.rdbuf(strm_buffer);
    MPI_Finalize();

    return 0;
}
