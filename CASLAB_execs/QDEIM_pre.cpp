#include "metadata.hpp"
#include "param.hpp"

#include <set>

using namespace ::std;

int main(int argc, char *argv[])
{
    MPI_Init(&argc, &argv);
    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); //Basic MPI intialization
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    ofstream sink("/dev/null");
    streambuf *strm_buffer = cout.rdbuf();

    paramMap inputFile("QR_pre.inp", rank); 	// input file

    double t2, t1;

    int debug_proc = 0;
    inputFile.getParamInt("stdout_proc", debug_proc);
    if (rank != debug_proc)
    {
        cout.rdbuf(sink.rdbuf());
    }

    // check whether user wants to compute bases or load them
    bool readSolSnaps = false;
	bool readRHSSnaps = false;
    inputFile.getParamBool("readSolSnaps", readSolSnaps); 	// whether to compute solution basis here
	inputFile.getParamBool("readRHSSnaps", readRHSSnaps); 	// whether to compute RHS basis here

	// solution snapshots or basis paths
	string inputSol, inputRHS;
	inputFile.getParamString("solInputString", inputSol); 	// PDP-demarcated input for solution data/basis
    inputFile.getParamString("rhsInputString", inputRHS); 	// PDP-demarcated input for RHS data/basis

	// parse solution and RHS basis strings
	vector<string> tokenSol, tokenRHS;
	cout << "Solution input string is: " << inputSol << endl;
    tokenparse(inputSol, "|", tokenSol);
	cout << "RHS input string is: " << inputRHS << endl;
    tokenparse(inputRHS, "|", tokenRHS);

	// if input strings are same, then resulting bases will be identical
	bool inputMatch = false;
	bool modesDiff = false;

	// if input are identical, bases will just be copied from solution basis to RHS basis
	if (inputSol == inputRHS) {
		cout << "Solution and RHS input strings were identical..." << endl;
		inputMatch = true;
	}

	int numModesSol, numModesRHS;
	string firstFileSnaps, firstFileBasis;

	// setup solution basis input
	meta *datasetSol;
    if (readSolSnaps) {
        datasetSol = new tecIO(tokenSol);
        firstFileSnaps = datasetSol->prefix + to_string(datasetSol->snap0) + datasetSol->suffix;
        dynamic_cast<tecIO *>(datasetSol)->activateReorder(firstFileSnaps.c_str());	
    	inputFile.getParamInt("numModesSol", numModesSol); 			 

    } else {
		datasetSol = new meta(tokenSol);
        firstFileBasis = datasetSol->prefix + to_string(datasetSol->snap0) + datasetSol->suffix;
		numModesSol = datasetSol->nSets;
	}

	// setup RHS/residual basis input, compare parameters against solution basis input
	meta *datasetRHS;
	if (readRHSSnaps) {
		datasetRHS = new tecIO(tokenRHS);
		firstFileSnaps = datasetRHS->prefix + to_string(datasetRHS->snap0) + datasetRHS->suffix;
		dynamic_cast<tecIO *>(datasetRHS)->activateReorder(firstFileSnaps.c_str());
		inputFile.getParamInt("numModesRHS", numModesRHS);

		// if dataset is same and mode counts are not same, note this
		// I'm pretty sure the readSolSnaps check is redundant, if inputMatch is already true
		if ( (readSolSnaps) && (inputMatch) && (numModesSol != numModesRHS) ) {
			modesDiff = true;
			cout << "Solution and RHS bases have same datasets, but different mode counts..." << endl;
		}

	// setup basis if reading basis
	} else {
		datasetRHS = new meta(tokenRHS);
		firstFileBasis = datasetRHS->prefix + to_string(datasetRHS->snap0) + datasetRHS->suffix;
		numModesRHS = datasetRHS->nSets;

		if (!readSolSnaps) {
			int metaCheck = compareMeta(datasetSol, datasetRHS);
			if (metaCheck == 2) {
				modesDiff = true;
				cout << "Solution and RHS bases have same datasets, but different mode counts..." << endl;
			} 
		}
	}
	int numModesMax = max(numModesSol, numModesRHS); // determines which basis has more modes, only relevant if bases come from same dataset

	// percentage of total cells to be sampled 
    double pSampling;
    inputFile.getParamDouble("pSampling", pSampling);

	// some I/O path strings
    string deimFolder, deimPrefix, dfd_itype_file;
    inputFile.getParamString("deimModesFolder", deimFolder); 	// location where DEIM interpolant modes will be written
    inputFile.getParamString("deimModesPrefix", deimPrefix); 	// prefix of DEIM interpolant mode files
    inputFile.getParamString("dfd_itype_file", dfd_itype_file); // path to dfd_itype.bin generated by pgrid.x

	PGrid *evenG;
    evenG = new PGrid(rank, size, 0);
	pMat *U, *A, *VT; 	// temporary basis matrices
	pMat *USol;
	pMat *URHS, *URHS_T;

	// ##### SETTING UP SOLUTION TRIAL BASIS ##### // 
	cout << "Loading solution basis..." << endl;

	int nCells = 0, nVars = 0;

	// compute SVD of FOM snapshots, if computing POD basis here
    if (readSolSnaps) {

        A = new pMat(datasetSol->nPoints, datasetSol->nSets, evenG, 0, 0, 0.0);
        t1 = MPI_Wtime();
        datasetSol->batchRead(A);
        t2 = MPI_Wtime();
        cout << "Load took " << t2 - t1 << " seconds" << endl;

        t1 = MPI_Wtime();

		// TODO: this would need to include options to set centering and normalization profiles
        tecIO *datasetTec = dynamic_cast<tecIO *>(datasetSol);
        datasetTec->calcAvg(A);
        datasetTec->subAvg(A);
        datasetTec->calcNorm(A);
        datasetTec->normalize(A);

        t2 = MPI_Wtime();
        cout << "Preprocessing took " << t2 - t1 << " seconds" << endl;
        int MSol = datasetSol->nPoints; 
		int NSol = datasetSol->nSets;

        vector<double> SSol;

        U = new pMat(MSol, min(MSol, NSol), evenG);
        VT = new pMat(min(MSol, NSol), NSol, evenG);
        SSol.resize(min(MSol, NSol));

        A->svd_run(MSol, NSol, 0, 0, U, VT, SSol);
        delete A;
        delete VT;

		nCells = dynamic_cast<tecIO *>(datasetSol)->nCells;
		nVars  = dynamic_cast<tecIO *>(datasetSol)->numVars;

		// extract numModesSol modes from U
		USol = new pMat(U->M, numModesSol, evenG);
		USol->changeContext(U, U->M, numModesSol, 0, 0, 0, 0);
		
		// if basis datasets match, also extract RHS basis here
		if (inputMatch) {
			URHS = new pMat(U->M, numModesRHS, evenG);
			// if mode counts are different, extract modes from U
			if (modesDiff) {
				URHS->changeContext(U, U->M, numModesRHS, 0, 0, 0, 0);

			// if bases are identical
			} else {
				URHS = USol; // just use same address, don't need to allocate more memory
			}

		}

		delete U; // don't need this anymore

    } else {
		// have to provide number of cells and variables, since reading from binary here (not SZPLT)
		inputFile.getParamInt("nCells", nCells); 
        inputFile.getParamInt("nVars", nVars);

		// read modes from disk
		USol = new pMat(datasetSol->nPoints, datasetSol->nSets, evenG);
		if (inputMatch || (modesDiff && (numModesSol < numModesMax))) {
			// if bases are identical, or if same basis set and RHS basis has more modes, just load it now
			URHS = new pMat(datasetRHS->nPoints, datasetRHS->nSets, evenG);
			datasetRHS->batchRead(URHS);
			USol->changeContext(URHS, URHS->M, numModesSol, 0, 0, 0, 0);
		} else {
			// if bases totally different, of solution basis set is same but has more modes than RHS basis, load solution basis now
			datasetSol->batchRead(USol);
		}

	}
    

	// ##### FINISH SOLUTION TRIAL BASIS ##### //

	// ##### SETTING UP RHS BASIS ##### //
	cout << "Loading RHS/residual basis..." << endl;

	// compute SVD of FOM snapshots, if computing POD basis here
	if (readRHSSnaps)
	{
		// if inputMatch, this has already been computed
		if (!inputMatch) {
			A = new pMat(datasetRHS->nPoints, datasetRHS->nSets, evenG, 0, 0, 0.0);
			t1 = MPI_Wtime();
			datasetRHS->batchRead(A);
			t2 = MPI_Wtime();
			cout << "Load took " << t2 - t1 << " seconds" << endl;

			t1 = MPI_Wtime();

			// TODO: this would need to include options to set centering and normalization profiles
			tecIO *datasetTec = dynamic_cast<tecIO *>(datasetRHS);
			datasetTec->calcAvg(A);
			datasetTec->subAvg(A);
			datasetTec->calcNorm(A);
			datasetTec->normalize(A);

			t2 = MPI_Wtime();
			cout << "Preprocessing took " << t2 - t1 << " seconds" << endl;
			int MRHS = datasetRHS->nPoints; 
			int NRHS = datasetRHS->nSets;

			vector<double> SRHS;

			U = new pMat(MRHS, min(MRHS, NRHS), evenG);
			VT = new pMat(min(MRHS, NRHS), NRHS, evenG);
			SRHS.resize(min(MRHS, NRHS));

			A->svd_run(MRHS, NRHS, 0, 0, U, VT, SRHS);
			delete A;
			delete VT;

			assert(nCells == dynamic_cast<tecIO *>(datasetRHS)->nCells);
			assert(nVars  == dynamic_cast<tecIO *>(datasetRHS)->numVars);

			// extract numModesRHS modes from U
			URHS = new pMat(U->M, numModesRHS, evenG);
			URHS->changeContext(U, U->M, numModesRHS, 0, 0, 0, 0);
			delete U; 
		}
		
		// URHS_T is just transpose of URHS
		URHS_T = new pMat(numModesRHS, URHS->M, evenG);
		URHS_T->transpose(URHS, URHS_T->M, URHS_T->N, 0, 0);

	} else {

		// if inputMatch, basis has already been copied
		if (!inputMatch) {
			URHS = new pMat(datasetRHS->nPoints, datasetRHS->nSets, evenG);

			// if same basis set, but RHS basis has fewer modes than solution basis, extract first numModesRHS modes from USol
			if (modesDiff && (numModesRHS < numModesMax)) {
				URHS->changeContext(USol, USol->M, numModesRHS, 0, 0, 0, 0);

			// otherwise just load from disk
			} else {
				// read RHS modes from disk
				datasetRHS->batchRead(URHS);
			}
		}

		// URHS_T is just transpose of URHS
		URHS_T = new pMat(numModesRHS, URHS->M, evenG); 						
		URHS_T->transpose(URHS);
		assert(URHS_T->N == nCells * nVars);

	}

	// ##### FINISH RHS BASIS ##### //

	// ##### START SAMPLING ##### //

	// compute QR factorization of U^T
	// This writes the pivot indices to disk, since it's easier to do this than collect to rank 0 process
	int PointsNeeded = nCells * pSampling; // total number of cells that need to be sampled
	vector<int> P;
    URHS_T->qr_run(URHS_T->M, URHS_T->N, 0, 0, P); 
	delete URHS_T; 

    vector<int> gP;		// gP will contain zero-indexed cell IDs of sampled cells
    vector<int> itype;
    set<int> samplingPoints;

	// get QR and boundary points
    t1 = MPI_Wtime();

	// all sampling here is done by rank 0 process
    if (rank == 0)
    {
        readMat("P.bin", gP); 	// automatically resizes gP to nDOF (the size of P.bin)
        gP.resize(numModesRHS); 	// resize it back down to numModesRHS. I feel like readMat just read the first numModesRHS integers? Seems inefficient.

		// sampled QR cells
		cout << "Extracting QR points..." << endl;
        for (int i = 0; i < gP.size(); i++)
        {
            gP[i]--; //switch to 0 indexing

            //switch to zero-indexed cell IDs
            cout << i << " " << gP[i] << " " << endl;
			gP[i] = gP[i] % nCells;
            auto check = samplingPoints.emplace(gP[i]);
            if (!check.second)
            {
                cout << "Repeated element" << endl;
            }
        }
        cout << "Goal is " << PointsNeeded << " points" << endl;
        cout << "Points after qr: " << samplingPoints.size() << " of " << PointsNeeded << endl;

		// get desired boundary labels
		int numSampledBounds = 0;
		string labelInputString;
		inputFile.getParamInt("numSampledBounds", numSampledBounds);
		vector<int> bcLabels(numSampledBounds);
		for (int i = 0; i < numSampledBounds; ++i) {
			labelInputString = "boundLabel" + to_string(i+1);
			inputFile.getParamInt(labelInputString, bcLabels[i]);
			cout << "Extracting boundary w/ label: " << bcLabels[i] << endl;
		}

		// add boundary cells, if any
		if (numSampledBounds > 0) {
			cout << "Extracting boundary points..." << endl;
			readMat(dfd_itype_file, itype);
			for (vector<int>::iterator it = itype.begin(); it != itype.end(); ++it)
			{
				// check if we want to sample this cell's itype (i.e. itype is in bcLabels)
				if (find(bcLabels.begin(), bcLabels.end(), *it) != bcLabels.end()) {
					auto check = samplingPoints.emplace(it - itype.begin()); //  add index of interator (i.e. cell_id, zero-indexed) 
					if (!check.second)
					{
						cout << "Repeated element " << it - itype.begin() << "\r";
					}
				}
			}
			cout << "Points after boundaries: " << samplingPoints.size() << " of " << PointsNeeded << endl;
			assert(PointsNeeded >= samplingPoints.size());
			cout << "Need " << PointsNeeded - samplingPoints.size() << " more points" << endl;
		} else {
			cout << "No boundaries sampled..." << endl;
		}
	}
	MPI_Barrier(MPI_COMM_WORLD);

	// oversampling
	int sampType;
	inputFile.getParamInt("sampType", sampType);
	bool allPoints = false;

	// random oversampling
	if (sampType == 1) {
		// do everything on rank 0
		if (rank == 0) {

			cout << "Randomly oversampling..." << endl;

			srand(1);				// seed random number generator
			vector<int> rPoints;
			rPoints.resize(nCells, 0);
			for (int i = 0; i < rPoints.size(); i++)
				rPoints[i] = i;

			// selecting points from a randomly shuffled list of integers from 0 to ncells-1				
			random_shuffle(rPoints.begin(), rPoints.end());
			for (vector<int>::iterator it = rPoints.begin(); it != rPoints.end(); ++it)
			{
				auto check = samplingPoints.emplace(*it);
				if (!check.second)
				{
					cout << "repeated element " << *it << "\r";
				}
				if (samplingPoints.size() == PointsNeeded) {
					cout << "All points found..." << endl;
					allPoints = true;
					break;
				}
			}

			// this should theoretically never happen
        	if (!allPoints) {
				cout << "Somehow, could not find enough sampled, this should never happen." << endl;
				return(-1);
			}

		}
	} else {
		cout << "Invalid choice of sampling type: " << sampType << endl;
	} 
	MPI_Barrier(MPI_COMM_WORLD);
	
	if (rank == 0) {
		gP.resize(samplingPoints.size(), 0);
        vector<double> gPD; // gP, but doubles
		gPD.resize(nCells, 0.0);
        copy(samplingPoints.begin(), samplingPoints.end(), gP.begin());

		cout << "Writing sampling points to disk..." << endl;
        for_each(gP.begin(), gP.end(), [](int &tt) { tt += 1; }); 	// put in one-indexed format for writing to disk
        printASCIIVecP0("samplingPoints.txt", gP, gP.size()); 		// writes sampling points to disk
        writeMat("Pall.bin", gP.size(), 1, gP); 					// also writing as bin file
        for_each(gP.begin(), gP.end(), [](int &tt) { tt -= 1; }); 	// changing back to zero-indexed cell IDs

		// mark every sampled cell in gPD with 1.0
        for (int i = 0; i < samplingPoints.size(); i++)
            gPD[gP[i]] = 1.0;

        vector<string> Pname;
        string tempname = "sampling";
        Pname.push_back(tempname);

		// could probably generalize this without the conditionals
        if (readSolSnaps) {
			dynamic_cast<tecIO *>(datasetSol)->writeSingleFile("sampling.szplt", Pname, gPD.data(), firstFileSnaps);
		} else if (readRHSSnaps) {
			dynamic_cast<tecIO *>(datasetRHS)->writeSingleFile("sampling.szplt", Pname, gPD.data(), firstFileSnaps);
		}

    }

    t2 = MPI_Wtime();
    cout << "Finding all samples took " << t2 - t1 << " seconds" << endl;

    if (rank != 0)
    {
        gP.resize(PointsNeeded, 0);
    }
    cout << "Broadcasting points..." << endl;
    MPI_Bcast(gP.data(), gP.size(), MPI_INT, 0, MPI_COMM_WORLD);

    cout << "Calculating DEIM interpolant..." << endl;
	// URHS_samp is P^T * URHS
    pMat *URHS_samp;
	URHS_samp = new pMat(gP.size() * nVars, numModesRHS, evenG);

	// extract rows of U
	// would it not be easier to just construct the full selection matrix P? Then multiply P^T * U?
    t1 = MPI_Wtime();
    for (int i = 0; i < gP.size(); i++)
    {
        cout << (double)i / gP.size() * 100 << " percent points extracted \r";
		for (int j = 0; j < nVars; j++)
			URHS_samp->changeContext(URHS, 1, numModesRHS, gP[i] + j * nCells, 0, i + j * gP.size(), 0, false);
    }
    t2 = MPI_Wtime();
    cout << "Extraction of RHS basis rows took " << t2 - t1 << " seconds" << endl;

    // URHS_samp->write_bin("URHS_samp.bin"); // write P^T * U to disk

    t1 = MPI_Wtime();

	// compute [P^T * URHS]^+ component of DEIM interpolant
	// write to disk
	cout << "Computing pseudo-inverse..." << endl;
    pMat *pinvURHS_samp = new pMat(URHS_samp->N, URHS_samp->M, evenG);
    pinvURHS_samp->pinv(URHS_samp);
    // pinvURHS_samp->write_bin("pinvURHS_samp.bin");
	delete URHS_samp;

	// compute USol^T * URHS
	cout << "Computing V^T * U ..." << endl;
    pMat *USol_URHS = new pMat(numModesSol, numModesRHS, evenG);
    USol_URHS->matrix_Product('T', 'N', numModesSol, numModesRHS, USol->M, USol, 0, 0, URHS, 0, 0, 1.0, 0.0, 0, 0); 

	// compute full DEIM interpolant, USol^T * URHS * [P^T * URHS]^+
	cout << "Computing complete DEIM interpolant..." << endl;
    pMat *deimInterp = new pMat(USol_URHS->M, pinvURHS_samp->N, evenG);
    deimInterp->matrix_Product('N', 'N', deimInterp->M, deimInterp->N, pinvURHS_samp->M, USol_URHS, 0, 0, pinvURHS_samp, 0, 0, 1.0, 0.0, 0, 0);
    t2 = MPI_Wtime();
    cout << "DEIM interpolant calculation took " << t2 - t1 << " seconds" << endl;

    // clean up
    delete USol_URHS;
    delete pinvURHS_samp;

    pMat *deimInterp_T = new pMat(deimInterp->N, deimInterp->M, deimInterp->pG);
    deimInterp_T->transpose(deimInterp);
    delete deimInterp;

	// write DEIM interpolant to disk
    // insert zeros where it is not sampled, for GEMS input
	cout << "Emplacing zeros into DEIM interpolant..." << endl;
    t1 = MPI_Wtime();
	pMat *deimInterpOut = new pMat(datasetRHS->nPoints, numModesSol, evenG);
    for (int i = 0; i < gP.size(); i++)
    {
        cout << (double)i / gP.size() * 100 << " percent points emplaced \r";
		for (int j = 0; j < nVars; j++)
			deimInterpOut->changeContext(deimInterp_T, 1, numModesSol, i + j * gP.size(), 0, gP[i] + j * nCells, 0, false);
    }
    t2 = MPI_Wtime();
    cout << "DEIM emplacement took " << t2 - t1 << " seconds" << endl;

	// what is the purpose of this? We can't use this stuff with GEMS, and it will get activated no matter what if computing the SVD
    if (readSolSnaps || readRHSSnaps) {
        tecIO *datasetOut = new tecIO();
        datasetOut->snap0 = 1;
        datasetOut->snapF = deimInterpOut->N;
        datasetOut->snapSkip = 1;
        datasetOut->nSets = deimInterpOut->N;
        //datasetOut->prefix = "deimInterp";
        //datasetOut->suffix = ".szplt";
        datasetOut->isInit = true;

		if (readSolSnaps) {
			datasetOut->meshFile = datasetSol->prefix + to_string(datasetSol->snap0) + datasetSol->suffix;
			datasetOut->varName = dynamic_cast<tecIO *>(datasetSol)->varName;
        	datasetOut->varIndex = dynamic_cast<tecIO *>(datasetSol)->varIndex;
		} else {
			datasetOut->meshFile = datasetRHS->prefix + to_string(datasetRHS->snap0) + datasetRHS->suffix;
			datasetOut->varName = dynamic_cast<tecIO *>(datasetRHS)->varName;
        	datasetOut->varIndex = dynamic_cast<tecIO *>(datasetRHS)->varIndex;
		}
        
        datasetOut->fixedMesh = true;
        datasetOut->getDimNodes();
        datasetOut->numVars = datasetOut->varName.size();
        datasetOut->nPoints = datasetOut->nCells * datasetOut->numVars;

        datasetOut->activateReorder(firstFileSnaps.c_str());
        datasetOut->activateGEMSbin(firstFileSnaps.c_str());
        t1 = MPI_Wtime();
        datasetOut->batchWrite(deimInterpOut, deimFolder, deimPrefix);
        t2 = MPI_Wtime();
        cout << "Output took " << t2 - t1 << " seconds" << endl;
    
	} else {
        meta *datasetOut = new meta();
        datasetOut->snap0 = 1;
        datasetOut->snapF = deimInterpOut->N;
        datasetOut->snapSkip = 1;
        datasetOut->nSets = deimInterpOut->N;
        datasetOut->prefix = "deimInterp";
        datasetOut->suffix = ".bin";
        datasetOut->isInit = true;

        datasetOut->nPoints = nCells * nVars;
        assert(datasetOut->nPoints == nCells * nVars);
        t1 = MPI_Wtime();
        datasetOut->batchWrite(deimInterpOut, deimFolder, deimPrefix);
        t2 = MPI_Wtime();
        cout << "Output took " << t2 - t1 << " seconds" << endl;
    }

    cout.rdbuf(strm_buffer);
    MPI_Finalize();

    return 0;
}
